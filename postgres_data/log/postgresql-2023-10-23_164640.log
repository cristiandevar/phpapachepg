2023-10-23 16:46:40.483 UTC [1] LOG:  starting PostgreSQL 16.0 on x86_64-pc-linux-musl, compiled by gcc (Alpine 12.2.1_git20220924-r10) 12.2.1 20220924, 64-bit
2023-10-23 16:46:40.484 UTC [1] LOG:  listening on IPv4 address "0.0.0.0", port 5432
2023-10-23 16:46:40.484 UTC [1] LOG:  listening on IPv6 address "::", port 5432
2023-10-23 16:46:40.515 UTC [1] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2023-10-23 16:46:40.755 UTC [31] LOG:  database system was shut down at 2023-10-20 17:01:05 UTC
2023-10-23 16:46:41.155 UTC [1] LOG:  database system is ready to accept connections
2023-10-23 16:51:40.841 UTC [29] LOG:  checkpoint starting: time
2023-10-23 16:51:41.135 UTC [29] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.086 s, sync=0.019 s, total=0.295 s; sync files=2, longest=0.011 s, average=0.010 s; distance=0 kB, estimate=0 kB; lsn=0/6545DF0, redo lsn=0/6545DB8
2023-10-23 17:00:37.272 UTC [38] ERROR:  syntax error at or near "as" at character 79
2023-10-23 17:00:37.272 UTC [38] STATEMENT:  create or replace function mostrar_ordenes_año(pd_year integer)
	returns table as
	$$
	query = """select date_part('month', orderdate), count(*)  from orders where date_part('year', orderdate)="""
	query += pd_year
	query += """group by date_part('month', orderdate) order by date_part('month', orderdate);"""
	
	return plpy.execute(query);
	$$
	language plpython3u;
2023-10-23 17:02:33.876 UTC [38] ERROR:  TypeError: can only concatenate str (not "int") to str
2023-10-23 17:02:33.876 UTC [38] CONTEXT:  Traceback (most recent call last):
	  PL/Python function "mostrar_ordenes_año", line 3, in <module>
	    query += pd_year
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:02:33.876 UTC [38] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:02:57.096 UTC [38] ERROR:  spiexceptions.SyntaxError: trailing junk after numeric literal at or near "1997g" at character 96
2023-10-23 17:02:57.096 UTC [38] QUERY:  select date_part('month', orderdate), count(*)  from orders where date_part('year', orderdate)=1997group by date_part('month', orderdate) order by date_part('month', orderdate);
2023-10-23 17:02:57.096 UTC [38] CONTEXT:  Traceback (most recent call last):
	  PL/Python function "mostrar_ordenes_año", line 6, in <module>
	    return plpy.execute(query);
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:02:57.096 UTC [38] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:03:40.004 UTC [38] ERROR:  spiexceptions.UndefinedTable: relation "orders" does not exist at character 54
2023-10-23 17:03:40.004 UTC [38] QUERY:  select date_part('month', orderdate), count(*)  from orders where date_part('year', orderdate)=1997 group by date_part('month', orderdate) order by date_part('month', orderdate);
2023-10-23 17:03:40.004 UTC [38] CONTEXT:  Traceback (most recent call last):
	  PL/Python function "mostrar_ordenes_año", line 6, in <module>
	    return plpy.execute(query);
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:03:40.004 UTC [38] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:04:03.708 UTC [73] ERROR:  key "li_month" not found in mapping
2023-10-23 17:04:03.708 UTC [73] HINT:  To return null in a column, add the value None to the mapping with the key named after the column.
2023-10-23 17:04:03.708 UTC [73] CONTEXT:  while creating return value
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:04:03.708 UTC [73] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:06:09.483 UTC [73] ERROR:  cannot change return type of existing function
2023-10-23 17:06:09.483 UTC [73] DETAIL:  Row type defined by OUT parameters is different.
2023-10-23 17:06:09.483 UTC [73] HINT:  Use DROP FUNCTION "mostrar_ordenes_año"(integer) first.
2023-10-23 17:06:09.483 UTC [73] STATEMENT:  create or replace function mostrar_ordenes_año(pd_year integer)
	returns table(li_month integer, li_qty_month integer) as
	$$
	query = """select date_part('month', orderdate) li_month, count(*) li_qty_month from orders where date_part('year', orderdate)="""
	query += str(pd_year)
	query += """ group by date_part('month', orderdate) order by date_part('month', orderdate);"""
	
	return plpy.execute(query);
	$$
	language plpython3u;
2023-10-23 17:06:27.654 UTC [73] ERROR:  invalid input syntax for type integer: "1.0"
2023-10-23 17:06:27.654 UTC [73] CONTEXT:  while creating return value
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:06:27.654 UTC [73] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:06:40.436 UTC [29] LOG:  checkpoint starting: time
2023-10-23 17:06:42.482 UTC [29] LOG:  checkpoint complete: wrote 18 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.839 s, sync=0.051 s, total=2.047 s; sync files=16, longest=0.012 s, average=0.004 s; distance=111 kB, estimate=111 kB; lsn=0/6561D98, redo lsn=0/6561D60
2023-10-23 17:12:31.414 UTC [73] ERROR:  syntax error at or near "resultado" at character 1
2023-10-23 17:12:31.414 UTC [73] STATEMENT:  resultado =  plpy.execute(query);
2023-10-23 17:14:10.955 UTC [73] ERROR:  cannot change return type of existing function
2023-10-23 17:14:10.955 UTC [73] DETAIL:  Row type defined by OUT parameters is different.
2023-10-23 17:14:10.955 UTC [73] HINT:  Use DROP FUNCTION "mostrar_ordenes_año"(integer) first.
2023-10-23 17:14:10.955 UTC [73] STATEMENT:  create or replace function mostrar_ordenes_año(pd_year integer)
	returns table(li_month integer, li_qty_month integer, li_qty_acum integer) as
	$$
	query = """select date_part('month', orderdate) li_month, count(*) li_qty_month from orders where date_part('year', orderdate)="""
	query += str(pd_year)
	query += """ group by date_part('month', orderdate) order by date_part('month', orderdate);"""
	
	resultado =  plpy.execute(query);
	
	yeld(int(resultado.li_month), int(resultado.li_qty_month), 0)
	$$
	language plpython3u;
2023-10-23 17:14:28.461 UTC [73] ERROR:  NameError: name 'yeld' is not defined
2023-10-23 17:14:28.461 UTC [73] CONTEXT:  Traceback (most recent call last):
	  PL/Python function "mostrar_ordenes_año", line 8, in <module>
	    yeld(int(resultado.li_month), int(resultado.li_qty_month), 0)
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:14:28.461 UTC [73] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:14:53.961 UTC [73] ERROR:  error fetching next item from iterator
2023-10-23 17:14:53.961 UTC [73] DETAIL:  AttributeError: 'PLyResult' object has no attribute 'li_month'
2023-10-23 17:14:53.961 UTC [73] CONTEXT:  Traceback (most recent call last):
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:14:53.961 UTC [73] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:16:31.089 UTC [73] ERROR:  error fetching next item from iterator
2023-10-23 17:16:31.089 UTC [73] DETAIL:  TypeError: list indices must be integers or slices, not str
2023-10-23 17:16:31.089 UTC [73] CONTEXT:  Traceback (most recent call last):
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:16:31.089 UTC [73] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:16:40.699 UTC [29] LOG:  checkpoint starting: time
2023-10-23 17:16:42.272 UTC [29] LOG:  checkpoint complete: wrote 14 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.385 s, sync=0.032 s, total=1.573 s; sync files=9, longest=0.012 s, average=0.004 s; distance=90 kB, estimate=109 kB; lsn=0/6578890, redo lsn=0/6578858
2023-10-23 17:17:12.715 UTC [73] ERROR:  error fetching next item from iterator
2023-10-23 17:17:12.715 UTC [73] DETAIL:  TypeError: list indices must be integers or slices, not str
2023-10-23 17:17:12.715 UTC [73] CONTEXT:  Traceback (most recent call last):
	PL/Python function "mostrar_ordenes_año"
2023-10-23 17:17:12.715 UTC [73] STATEMENT:  select * from mostrar_ordenes_año(1997);
2023-10-23 17:20:33.073 UTC [73] ERROR:  could not compile PL/Python function "mostrar_ordenes_año"
2023-10-23 17:20:33.073 UTC [73] DETAIL:  IndentationError: expected an indented block after 'for' statement on line 10 (<string>, line 11)
2023-10-23 17:20:33.073 UTC [73] STATEMENT:  create or replace function mostrar_ordenes_año(pd_year integer)
	returns table(li_month integer, li_qty_month integer, li_qty_acum integer) as
	$$
	query = """select date_part('month', orderdate) as li_month, count(*) as li_qty_month from orders where date_part('year', orderdate)="""
	query += str(pd_year)
	query += """ group by date_part('month', orderdate) order by date_part('month', orderdate);"""
	
	resultado =  plpy.execute(query);
	
	acum = 0
	for r in resultado:
	acum += r['li_qty_month']
	yield(int(r['li_month']), int(r['li_qty_month']), acum)
	$$
	language plpython3u;
2023-10-23 17:21:40.391 UTC [29] LOG:  checkpoint starting: time
2023-10-23 17:21:41.215 UTC [29] LOG:  checkpoint complete: wrote 7 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.661 s, sync=0.021 s, total=0.825 s; sync files=7, longest=0.011 s, average=0.003 s; distance=48 kB, estimate=103 kB; lsn=0/65848C0, redo lsn=0/6584888
2023-10-23 17:22:40.213 UTC [1] LOG:  received fast shutdown request
2023-10-23 17:22:40.227 UTC [1] LOG:  aborting any active transactions
2023-10-23 17:22:40.229 UTC [73] FATAL:  terminating connection due to administrator command
2023-10-23 17:22:40.250 UTC [1] LOG:  background worker "logical replication launcher" (PID 34) exited with exit code 1
2023-10-23 17:22:40.354 UTC [29] LOG:  shutting down
2023-10-23 17:22:40.367 UTC [29] LOG:  checkpoint starting: shutdown immediate
2023-10-23 17:22:40.574 UTC [29] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.054 s, sync=0.001 s, total=0.220 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=93 kB; lsn=0/6584970, redo lsn=0/6584970
2023-10-23 17:22:40.667 UTC [1] LOG:  database system is shut down
